package com.ly.facade.pattern;

/**
 * @ProjectName: Java-Guide
 * @Package: com.ly.facade.no_pattern
 * @ClassName: Main
 * @Author: lin
 * @Description: 用于演示在使用模式时的客户端调用
 * @Date: 2019/7/18 21:21
 * @Version: 1.0
 */
public class Main {
    public static void main(String[] args) {
        // 在使用了外观模式下，不需要再与代码生成器内部的多个子模块进行交互，
        // 只需要使用代码生产功能区暴露的接口（外观类）即可，具体的生成过程已经在接口（外观类）中定义好了
        // 实现类客户端和代码生成器中的具体功能类进行解耦
        new Facade().generate();
    }

    /**
     * 外观模式的目的不是为了给子系统添加新的功能接口，而是为了人外部减少与子系统内部过个模块的交合，松散耦合，从而
     * 让客户端能够更加简单的调用子系统。
     * 外观模式将指定的功能模块进行组合，提供给外部使用，使外部客户端不知道具体的实现，屏蔽了客户端和系统内模块的交合
     * 同时也易于修改组合过程，比如要先生存 数据层在生成逻辑层，只需要修改 Facade 的实现即可。
     * 同时也做到了复用，相同的功能，只需要调用相同的 Facade 方法即可。
     *
     * 在有了外观模式的情况下，也可以不使用外观模式，子使用子系统中的摸一个功能子模块，如生成 数据层 的模块
     *
     * 外观模式的本质是：封装交互，简化调用。
     * */
}
