package com.ly.strategy.strategy;

/**
 * @ProjectName: Java-Guide
 * @Package: com.ly.strategy.strategy
 * @ClassName: Client
 * @Author: lin
 * @Description: 策略模式的简单事例
 * @Date: 2019/8/7 20:23
 * @Version: 1.0
 */
public class Client {
    public static void main(String[] args) {
        Context context = new Context(new ConcreteStrategyA());
        context.contextInterface();
    }

    /**
     * 策略模式的优点：
     *      定义一系列算法：策略模式的功能就是定义一系列算法，实现让这些算法可以相互替换。所以会为这一系列算法定义
     *      公共的接口，一约束一系列算法要实现的功能。如果这一系列算法具有公共的功能可以实现为抽象类，把这些实现放
     *      到父类中。
     *      避免多重条件语句：策略模式的一系列算法是平等的，是可以互换的，写在一起就是通过 if-else 结构来组织，如
     *      果此时具体的算法实现中又有条件语句，就构成了多重条件语句，使用策略模式可以避免这样的多重条件语句。
     *      更好的扩展性：在策略模式中扩展新的策略模式非常的容易，只需要增加新的策略实现类，然后在使用策略地方选择
     *      使用这个新的策略实现就可以了。
     *
     * 策略模式的缺点：
     *      客户必须了解每种策略实现：让客户端来选择具体使用哪一种策略，就需要客户端了解所有的策略实现的功能和不同，
     *      才能做出正确的选择，这样就暴露了具体的实现细节。
     *      增加了对象数目：策略模式是将每种具体的策略读封装为具体的类，如果策略很多那么对应就会有很多的类
     *      只适合扁平的算法结构：策略模式的一系列算法是平等的，是可以相互替换的，事实上构成了一个扁平的算法结构，也
     *      就是一个接口下，有多个平级的策略算法，就相当于兄弟算法。而且在运行时候只有一个算法被使用，这就限制了算法
     *      的使用层级，使用的时候不能嵌套。
     *      对于出现多个嵌套使用算法的情况，比如折上折、折后返券等业务的实现，需要组合或嵌套多个算法的时候，可以考虑
     *      使用装饰模式，或是变形的责任链模式或是AOP等方式来实现。
     *
     * 策略模式的本质是：分离算法，选择实现。
     * */
}
