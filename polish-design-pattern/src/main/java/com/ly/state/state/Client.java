package com.ly.state.state;

/**
 * @ProjectName: idea_workspace
 * @Package: com.ly.state.state
 * @ClassName: Client
 * @Author: lin
 * @Description: 状态模式的简单实例
 * @Date: 2019-08-08 10:52
 * @Version: 1.0
 */
public class Client {
    public static void main(String[] args) {
        // 创建相应的状态
        State a = new ConcreteStateA ();
        State b = new ConcreteStateB ();

        Context context = new Context ();
        // 设置对应的状态
        context.setState (b);
        context.handle ("start");
    }

    /**
     * 状态模式的优点：
     *      简化应用逻辑控制：状态模式使用一个单独的类来封装一个状态的处理。如果把一个大的程序控制分成很多的小块，每块单独定义一个状态来代表。
     *      那么就可以就可以把这些逻辑控制的代码分散到很多单独的状态类中去，这样就把着眼点从执行状态提高到整个对象的状态，使得代码结构化和意
     *      图更加清晰，从而简化应用的逻辑控制。对于依赖与状态的 if-else，理论上来讲，也可以改变成应用状态模式来实现，把每个if或else块定义一
     *      个状态，那么就可以把块内的功能代码移动到状态处理类中，从而减少if-else，避免出现巨大的条件判断语句。
     *      更好的分离状态和行为：状态模式通过设计所有状态类的公共接口，把状态和状态对应的行为分离开，把所有和一个特定的状态相关的行为放入到
     *      一个状态类中，使得应用程序在控制的时候，只需要关心状态的切换，而不用关心这个状态对应的正在处理。
     *      更好的扩展性：引入了状态处理的公共接口后，使得扩展新的状态变得非常的容易，只需要增加一个实现状态接口的新实现类，然后在进行状态维
     *      护的地方，设置状态变化到这个新的实现类即可。
     *      显示化进行状态转换：状态模式为不同的状态引入独立的对象，是的对象的转换变得更加的明确。而且状态对象可以保证上下文不会发生内部状态
     *      不一致的情况，因为上下文中只有一个变量来记录撞他对象，只要为这一个变量赋值即可。
     *
     *  状态模式有一个明显的缺点：一个状态对应一个状态处理类，会使得程序引入太多的状态类，这样程序变得杂乱。
     *
     *  状态模式的本质是：根据状态来选择和分离行为。
     *
     * */
}
